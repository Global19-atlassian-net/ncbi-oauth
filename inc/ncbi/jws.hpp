/*==============================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 */

#ifndef _hpp_ncbi_jws_
#define _hpp_ncbi_jws_

#ifndef _hpp_ncbi_jwk_
#include <ncbi/jwk.hpp>
#endif

#include <vector>
#include <string>

/**
 * @file ncbi/jwa.hpp
 * @brief JSON Web Algorithms - RFC 7515
 */

namespace ncbi
{
    class JWPayload;

    /**
     * @typedef JWS
     * @brief JSON Web Signature - RFC 7515: Line 350
     * A data structure representing a digitally signed message
     */
    typedef std :: string JWS;

    /**
     * @class JWSMgr
     * @brief JWS Management
     * globally accessible factory functions
     */
    class JWSMgr
    {
    public:

        /**
         * @fn signCompact
         * @overload sign using compact serialization - RFC 7515: Line 376
         * @param key C++ reference to the JWK signing key
         * @param payload a pointer to bytes to be signed
         * @param bytes the size in bytes of payload
         * @return JWS encoded string
         * sign using compact serialization method.
         * generates a JOSE header to describe signature,
         * including algorithm and key-id.
         */
        static JWS signCompact ( const JWK & key,
            const void * payload, size_t bytes );

        /**
         * @fn extract
         * @overload verify a JWS and extracts its payload
         * @param payload an out parameter for JWS payload
         * @param val_keys a set of signature validation keys
         * @param jws the JWS to be verified
         * @return a JWKRef with the key that verified signature
         */
        static JWKRef extract ( JWPayload & payload,
            const JWKSet & val_keys, const JWS & jws );

    private:

        /**
         * @fn signCompact
         * @overload sign with ext. header using compact serialization - RFC 7515: Line 376
         * @param key C++ reference to the JWK signing key
         * @param jose a JSONObject reference representing user JOSE header values
         * @param payload a pointer to bytes to be signed
         * @param bytes the size in bytes of payload
         * @return JWS encoded string
         * makes use of an externally provided JOSE header object.
         * the JOSE header SHOULD be generated by JWS, but is sometimes abused
         * to include headers from JWT or ...
         */
        static JWS signCompact ( const JWK & key, JSONObject & jose,
            const void * payload, size_t bytes );

        /**
         * @fn extractCompact
         * @overload verify a JWS and extracts its payload
         * @param payload a return parameter for JWS payload
         * @param val_keys a set of signature validation keys
         * @param jws the JWS to be verified
         * @return a JWKRef with the key that verified signature
         */
        static JWKRef extractCompact ( JWPayload & payload,
            const JWKSet & val_keys, const JWS & jws );

        /**
         * @fn verifyContents
         * @brief verify a JWS with inflated JOSE header
         * @param val_keys a set of signature validation keys
         * @param jose the JOSE header already processed by another trusted component
         * @param contents the base64url-encoded hdr.payload that was signed
         * @param signature the base64url-encoded signature
         * @return a JWKRef with the key that verified signature
         */
        static JWKRef verifyContents ( const JWKSet & val_keys, JSONObject & jose,
            const std :: string & contents, const std :: string & signature );

        /**
         * @fn verifyHeader
         * @brief supposed to understand 100% of the header
         * @param jose the header form of a JSON object
         * JWS is an encapsulation and unfortunately doesn't own the JOSE
         * header, making it difficult or impossible to require it to
         * understand all possible contents without violating modularity
         * of the JWT layer, for example.
         */
        static void verifyHeader ( const JSONObject & jose );

        friend class JWTMgr;
    };


    /*=================================================*
     *                   EXCEPTIONS                    *
     *=================================================*/
    DECLARE_JWX_MSG_EXCEPTION ( JWSException, JWX );
}

#endif // _hpp_ncbi_jws_
